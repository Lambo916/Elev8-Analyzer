/*** PATCH: Fix PDF font consistency + stop footer overlap (safe & minimal)
 * Goal: Reset body font after every page add, and keep text clear of the footer.
 ***********************************************************************************************/

console.log('[PDF Export] Version 2 loaded - Polished margins (12mm/25mm), header divider fix, disclaimer footer');

window.YBG_PDF = window.YBG_PDF || {};

(function (ns) {
  // --- Layout & typography tokens (keep aligned with template) ---
  const MARGINS = { top: 12, right: 56, bottom: 25, left: 56 }; // reduced for tighter layout
  const BODY    = { font: "helvetica", weight: "normal", size: 12, color: [50, 50, 50] };

  // Apply standard body style (call whenever you start writing on a page)
  ns.applyBodyStyle = function applyBodyStyle(doc) {
    doc.setFont(BODY.font, BODY.weight);
    doc.setFontSize(BODY.size);
    doc.setTextColor(...BODY.color);
  };

  // Should we break before drawing the next line? (prevents footer overlap)
  ns.shouldBreakBeforeLine = function shouldBreakBeforeLine(doc, cursorY, lineHeight) {
    const pageH = doc.internal.pageSize.getHeight();
    return cursorY > (pageH - MARGINS.bottom - lineHeight);
  };

  // Safe page add: always reset fonts and redraw header
  ns.safeAddPage = function safeAddPage(doc, currentPageNumber, drawHeaderFn) {
    const nextPage = currentPageNumber + 1;
    doc.addPage();
    ns.applyBodyStyle(doc);          // <- reset font/size/weight every new page
    if (typeof drawHeaderFn === "function") drawHeaderFn(nextPage);
    return nextPage;
  };

  // Safer footer (use in your export finalize loop)
  ns.drawFooter = function drawFooter(doc, pageNumber, pageCount) {
    const h = doc.internal.pageSize.getHeight();
    doc.setFont("helvetica", "normal");
    doc.setFontSize(9);
    doc.setTextColor(110, 110, 110);
    const toolkitName = (typeof getToolkitName === 'function') ? getToolkitName() : 'Elev8 Analyzer';
    const footer = `Generated by ${toolkitName}   Page ${pageNumber} of ${pageCount}`;
    // place ~24pt above bottom; text stays clear of content due to bottom margin
    doc.text(footer, MARGINS.left, h - 24);
    
    // Add disclaimer below main footer text
    doc.setFontSize(7);
    doc.setTextColor(130, 130, 130);
    const disclaimer = "Disclaimer: For informational purposes only. Not legal, tax, or financial advice.";
    doc.text(disclaimer, MARGINS.left, h - 18);
  };

  // Expose margins for callers
  ns.PDF_MARGINS = MARGINS;
})(window.YBG_PDF);

/* public/pdf-export.js
   YBG PDF Export - Production Quality Implementation
   - Consistent typography across all pages
   - Clean pagination with proper word wrapping
   - Correct timestamp-based result filtering
   - No footer/header overlap
*/

(() => {
  'use strict';

  // ---- jsPDF Lazy Loader ---------------------------------------------------
  const loadJsPDF = (() => {
    let cached;
    return async () => {
      if (cached) return cached;
      if (window.jspdf?.jsPDF) {
        cached = window.jspdf.jsPDF;
        return cached;
      }
      const src = "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js";
      await new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = src;
        script.onload = resolve;
        script.onerror = () => reject(new Error("Failed to load jsPDF"));
        document.head.appendChild(script);
      });
      cached = window.jspdf.jsPDF;
      return cached;
    };
  })();

  // ---- Constants (A4 Portrait) ---------------------------------------------
  const PAGE = {
    width: 210,  // mm
    height: 297  // mm
  };

  const MARGINS = {
    top: 12,
    bottom: 25,
    left: 16,
    right: 16
  };

  const HEADER = {
    height: 18,      // Total header area height
    iconSize: 10,    // Icon diameter
    iconRing: 0.8    // Ring thickness
  };

  const FOOTER = {
    height: 15       // Total footer area height including text
  };

  // Safe content area calculation
  const CONTENT = {
    top: MARGINS.top + HEADER.height,
    bottom: PAGE.height - MARGINS.bottom - FOOTER.height,
    left: MARGINS.left,
    right: PAGE.width - MARGINS.right,
    width: PAGE.width - MARGINS.left - MARGINS.right
  };
  CONTENT.height = CONTENT.bottom - CONTENT.top;

  // ---- Typography Tokens (Global, Applied Per Page) ------------------------
  const TYPOGRAPHY = {
    fontFamily: "helvetica",
    
    // Sizes
    bodySize: 11,
    h2Size: 13,
    h3Size: 11,
    footerSize: 9,
    headerTitleSize: 12,
    
    // Line heights
    lineHeight: 5.5,  // mm (approx 1.35x for 11pt)
    h2LineHeight: 6.5,
    h3LineHeight: 5.8,
    paragraphSpacing: 3.5,
    
    // Colors (RGB arrays for jsPDF)
    colorBody: [51, 51, 51],      // #333
    colorHeading: [17, 17, 17],   // #111  
    colorMeta: [102, 102, 102],   // #666
    colorAccent: [0, 184, 124]    // Emerald Green accent (#00B87C) for Elev8 Analyzer
  };

  // ---- Global Typography Application ---------------------------------------
  function applyGlobalTypography(doc) {
    doc.setFont(TYPOGRAPHY.fontFamily, "normal");
    doc.setFontSize(TYPOGRAPHY.bodySize);
    doc.setTextColor(...TYPOGRAPHY.colorBody);
    doc.setLineWidth(0.2);
  }

  // ---- Toolkit Configuration -----------------------------------------------
  function getToolkitName() {
    return window.currentToolkitName || "Elev8 Analyzer";
  }

  function getToolkitIcon() {
    // Use the full-size logo for PDF exports (not the tiny favicon)
    return window.currentToolkitLogo || "elev8-logo.png";
  }

  // ---- Image Loading -------------------------------------------------------
  async function loadImageAsDataURL(url) {
    if (!url) return null;
    try {
      const response = await fetch(url);
      if (!response.ok) return null;
      const blob = await response.blob();
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => resolve(null);
        reader.readAsDataURL(blob);
      });
    } catch {
      return null;
    }
  }

  // ---- Watermark Drawing ---------------------------------------------------
  function drawWatermark(doc, iconDataUrl) {
    if (!iconDataUrl) return;
    
    try {
      // Calculate center position for watermark
      const watermarkSize = 80; // mm - large but subtle watermark
      const centerX = PAGE.width / 2 - watermarkSize / 2;
      const centerY = PAGE.height / 2 - watermarkSize / 2;
      
      // Set opacity to 6% (0.06) for subtle watermark
      doc.setGState(new doc.GState({ opacity: 0.06 }));
      
      // Draw the logo centered on page with high quality
      doc.addImage(iconDataUrl, "PNG", centerX, centerY, watermarkSize, watermarkSize, "", "SLOW");
      
      // Restore full opacity for content
      doc.setGState(new doc.GState({ opacity: 1.0 }));
    } catch (e) {
      // Silent fail for watermark
      console.warn('Failed to add watermark:', e);
    }
  }

  // ---- Header Drawing ------------------------------------------------------
  function drawHeader(doc, pageNum, iconDataUrl) {
    const x = MARGINS.left;
    const y = MARGINS.top;
    
    // CompliPilot logo with proper aspect ratio (square logo 1015x1001 = 1:1)
    const logoSize = 10;  // mm - reduced for tighter layout
    
    if (iconDataUrl) {
      try {
        const logoX = x;
        const logoY = y;
        
        // Draw square logo with high quality (SLOW compression for crisp rendering)
        doc.addImage(iconDataUrl, "PNG", logoX, logoY, logoSize, logoSize, "", "SLOW");
      } catch (e) {
        // Silent fail for logo
      }
    }
    
    // Title
    doc.setFont(TYPOGRAPHY.fontFamily, "bold");
    doc.setFontSize(TYPOGRAPHY.headerTitleSize);
    doc.setTextColor(...TYPOGRAPHY.colorHeading);
    doc.text(getToolkitName(), x + logoSize + 3, y + 6);
    
    // Add subtle emerald green divider line WITHIN header area (not overlapping content)
    const dividerY = y + HEADER.height - 3;  // Position within header boundary
    doc.setDrawColor(...TYPOGRAPHY.colorAccent); // Emerald Green (#00B87C)
    doc.setLineWidth(0.3);
    doc.line(CONTENT.left, dividerY, CONTENT.right, dividerY);
    
    // Reset to body typography
    applyGlobalTypography(doc);
  }

  // ---- Footer Drawing ------------------------------------------------------
  async function drawFooter(doc, pageNum, totalPages) {
    const mainFooterY = PAGE.height - MARGINS.bottom + 6;
    const copyrightY = PAGE.height - MARGINS.bottom + 11;
    const disclaimerY = PAGE.height - MARGINS.bottom + 16;
    
    // Emerald green accent line above footer (brand accent)
    doc.setDrawColor(...TYPOGRAPHY.colorAccent); // Emerald Green #00B87C
    doc.setLineWidth(0.4);
    doc.line(CONTENT.left, CONTENT.bottom + 2, CONTENT.right, CONTENT.bottom + 2);
    
    // Main footer row
    doc.setFont(TYPOGRAPHY.fontFamily, "normal");
    doc.setFontSize(TYPOGRAPHY.footerSize);
    doc.setTextColor(...TYPOGRAPHY.colorMeta);
    
    // Left side: Elev8 Analyzer branding
    doc.text(`Elev8 Analyzer Report • Powered by YourBizGuru.com`, CONTENT.left, mainFooterY);
    
    // Right side: "Page X of Y"
    const pageText = `Page ${pageNum} of ${totalPages}`;
    const pageWidth = doc.getTextWidth(pageText);
    doc.text(pageText, CONTENT.right - pageWidth, mainFooterY);
    
    // Copyright below (small, muted, left-aligned)
    doc.setFont(TYPOGRAPHY.fontFamily, "normal");
    doc.setFontSize(7); // Smaller than footer size
    doc.setTextColor(120, 120, 120); // More muted gray
    const copyright = "© 2025 Elev8 Analyzer – All Rights Reserved";
    doc.text(copyright, CONTENT.left, copyrightY);
    
    // Disclaimer on last line - matching the app footer
    doc.setFont(TYPOGRAPHY.fontFamily, "italic");
    doc.setFontSize(7);
    doc.setTextColor(130, 130, 130);
    const disclaimer = "Disclaimer: For informational purposes only. Not legal, tax, or financial advice.";
    doc.text(disclaimer, CONTENT.left, disclaimerY);
    
    // Reset to body typography
    applyGlobalTypography(doc);
  }

  // ---- Text Processing -----------------------------------------------------
  function parseChecklistTable(lines, startIdx) {
    const rows = [];
    let i = startIdx;
    
    while (i < lines.length) {
      const line = lines[i].trim();
      
      // Stop at next heading or separator
      if (line.startsWith('##') || line.startsWith('---')) {
        break;
      }
      
      // Skip blank lines (don't stop, just continue)
      if (line === '') {
        i++;
        continue;
      }
      
      // Parse checklist items (bullet points or numbered)
      if (line.match(/^[•✓\-\*\d\.]/)) {
        const cleanText = line.replace(/^[•✓\-\*\d\.\s]+/, '').trim();
        rows.push([cleanText, '☐ Pending', '']);
      }
      
      i++;
    }
    
    return {
      endIdx: i,
      table: {
        headers: ['Requirement', 'Status/Action', 'Notes'],
        columns: [
          { width: 0.55, align: 'left' },
          { width: 0.25, align: 'left' },
          { width: 0.20, align: 'left' }
        ],
        rows
      }
    };
  }
  
  function parseTimelineTable(lines, startIdx) {
    const rows = [];
    let i = startIdx;
    
    while (i < lines.length) {
      const line = lines[i].trim();
      
      // Stop at next heading or separator
      if (line.startsWith('##') || line.startsWith('---')) {
        break;
      }
      
      // Skip blank lines (don't stop, just continue)
      if (line === '') {
        i++;
        continue;
      }
      
      // Try to parse as table row (pipe-separated)
      if (line.includes('|')) {
        const cells = line.split('|').map(c => c.trim()).filter(c => c && c !== '---');
        if (cells.length >= 3 && !cells[0].match(/^(Milestone|Phase|Task|Activity)/i)) {
          rows.push(cells.slice(0, 4)); // Take first 4 columns
        }
      }
      // Parse as list item
      else if (line.match(/^[•\-\*\d\.]/)) {
        const cleanText = line.replace(/^[•\-\*\d\.\s]+/, '').trim();
        rows.push([cleanText, 'TBD', 'TBD', '']);
      }
      
      i++;
    }
    
    return {
      endIdx: i,
      table: {
        headers: ['Phase', 'Activity', 'Timeframe', 'Milestone'],
        columns: [
          { width: 0.25, align: 'left' },
          { width: 0.30, align: 'left' },
          { width: 0.20, align: 'left' },
          { width: 0.25, align: 'left' }
        ],
        rows
      }
    };
  }
  
  function parseRiskMatrixTable(lines, startIdx) {
    const rows = [];
    let i = startIdx;
    
    while (i < lines.length) {
      const line = lines[i].trim();
      
      // Stop at next heading or separator
      if (line.startsWith('##') || line.startsWith('---')) {
        break;
      }
      
      // Skip blank lines (don't stop, just continue)
      if (line === '') {
        i++;
        continue;
      }
      
      // Try to parse as table row (pipe-separated)
      if (line.includes('|')) {
        const cells = line.split('|').map(c => c.trim()).filter(c => c && c !== '---');
        if (cells.length >= 3 && !cells[0].match(/^(Risk|Consequence)/i)) {
          rows.push(cells.slice(0, 4)); // Take first 4 columns
        }
      }
      
      i++;
    }
    
    return {
      endIdx: i,
      table: {
        headers: ['Risk', 'Severity', 'Likelihood', 'Mitigation'],
        columns: [
          { width: 0.25, align: 'left' },
          { width: 0.15, align: 'left', isSeverity: true },
          { width: 0.15, align: 'left' },
          { width: 0.45, align: 'left' }
        ],
        rows
      }
    };
  }
  
  function parseReferencesTable(lines, startIdx) {
    const rows = [];
    let i = startIdx;
    
    while (i < lines.length) {
      const line = lines[i].trim();
      
      // Stop at next heading or separator
      if (line.startsWith('##') || line.startsWith('---')) {
        break;
      }
      
      // Skip blank lines (don't stop, just continue)
      if (line === '') {
        i++;
        continue;
      }
      
      // Parse links or list items
      if (line.match(/^[•\-\*\d\.]/)) {
        const cleanText = line.replace(/^[•\-\*\d\.\s]+/, '').trim();
        
        // Try to extract URL
        const urlMatch = cleanText.match(/(https?:\/\/[^\s]+)/);
        if (urlMatch) {
          const url = urlMatch[1];
          const source = cleanText.replace(url, '').replace(/[:\-\(\)]/g, '').trim();
          rows.push([source || 'Reference', url]);
        } else {
          rows.push([cleanText, '']);
        }
      }
      
      i++;
    }
    
    return {
      endIdx: i,
      table: {
        headers: ['Source', 'URL/Notes'],
        columns: [
          { width: 0.35, align: 'left' },
          { width: 0.65, align: 'left' }
        ],
        rows
      }
    };
  }
  
  function parseBudgetNarrativeTable(lines, startIdx) {
    const rows = [];
    let i = startIdx;
    
    while (i < lines.length) {
      const line = lines[i].trim();
      
      // Stop at next heading or separator
      if (line.startsWith('##') || line.startsWith('---')) {
        break;
      }
      
      // Skip blank lines (don't stop, just continue)
      if (line === '') {
        i++;
        continue;
      }
      
      // Parse budget line items (bullet points or numbered)
      if (line.match(/^[•\-\*\d\.]/)) {
        const cleanText = line.replace(/^[•\-\*\d\.\s]+/, '').trim();
        
        // Try to extract category and amount
        // Format: "Category ($X,XXX): Description"
        const match = cleanText.match(/^([^($]+?)(?:\s*\(?\$?([\d,]+)\)?)?:\s*(.+)$/);
        if (match) {
          const category = match[1].trim();
          const amount = match[2] ? `$${match[2]}` : '';
          const description = match[3].trim();
          rows.push([category, amount, description]);
        } else {
          // Fallback: entire line as description
          rows.push([cleanText, '', '']);
        }
      }
      
      i++;
    }
    
    return {
      endIdx: i,
      table: {
        headers: ['Budget Category', 'Amount', 'Justification'],
        columns: [
          { width: 0.25, align: 'left' },
          { width: 0.15, align: 'left' },
          { width: 0.60, align: 'left' }
        ],
        rows
      }
    };
  }
  
  function parseContent(text) {
    if (!text) return [];
    
    const lines = text.split(/\r?\n/);
    const blocks = [];
    let i = 0;
    
    while (i < lines.length) {
      const line = lines[i];
      const trimmed = line.trim();
      
      // Check for table sections based on heading
      if (trimmed.startsWith('## ')) {
        const heading = trimmed.substring(3).trim().toLowerCase();
        
        blocks.push({
          type: 'h2',
          text: trimmed.substring(3).trim()
        });
        i++;
        
        // Detect and parse table sections
        if (heading.includes('budget') && heading.includes('narrative')) {
          const result = parseBudgetNarrativeTable(lines, i);
          if (result.table.rows.length > 0) {
            blocks.push({ type: 'table', data: result.table });
            i = result.endIdx;
            continue;
          }
        } else if (heading.includes('timeline') || heading.includes('implementation') || heading.includes('schedule')) {
          const result = parseTimelineTable(lines, i);
          if (result.table.rows.length > 0) {
            blocks.push({ type: 'table', data: result.table });
            i = result.endIdx;
            continue;
          }
        } else if (heading.includes('checklist') || heading.includes('requirements')) {
          const result = parseChecklistTable(lines, i);
          if (result.table.rows.length > 0) {
            blocks.push({ type: 'table', data: result.table });
            i = result.endIdx;
            continue;
          }
        } else if (heading.includes('risk') || heading.includes('matrix')) {
          const result = parseRiskMatrixTable(lines, i);
          if (result.table.rows.length > 0) {
            blocks.push({ type: 'table', data: result.table });
            i = result.endIdx;
            continue;
          }
        } else if (heading.includes('reference') || heading.includes('resource') || heading.includes('source')) {
          const result = parseReferencesTable(lines, i);
          if (result.table.rows.length > 0) {
            blocks.push({ type: 'table', data: result.table });
            i = result.endIdx;
            continue;
          }
        }
        
        continue;
      }
      else if (trimmed.startsWith('### ')) {
        blocks.push({
          type: 'h3', 
          text: trimmed.substring(4).trim()
        });
      } else if (trimmed.startsWith('---')) {
        blocks.push({
          type: 'separator',
          text: ''
        });
      } else if (trimmed.length > 0) {
        // Check if this is a metadata line
        const isMetadata = blocks.length < 15 &&
          (trimmed.match(/^(Generated|Entity|Type|Jurisdiction|Filing|Deadline):\s*.+/) ||
           trimmed.startsWith('**Generated:'));
        
        blocks.push({
          type: isMetadata ? 'metadata' : 'paragraph',
          text: line
        });
      } else {
        blocks.push({
          type: 'blank',
          text: ''
        });
      }
      
      i++;
    }
    
    return blocks;
  }

  // ---- Text Cleaning -------------------------------------------------------
  function cleanMarkdown(text) {
    // Remove markdown bold markers (**text** or __text__)
    return text.replace(/\*\*(.+?)\*\*/g, '$1').replace(/__(.+?)__/g, '$1');
  }

  // ---- Word Wrapping Algorithm ---------------------------------------------
  function wrapText(doc, text, maxWidth, fontSize) {
    doc.setFontSize(fontSize);
    
    // Clean markdown markers before wrapping
    const cleanText = cleanMarkdown(text);
    
    const words = cleanText.split(/\s+/);
    const lines = [];
    let currentLine = '';
    
    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const testWidth = doc.getTextWidth(testLine);
      
      if (testWidth > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    
    if (currentLine) {
      lines.push(currentLine);
    }
    
    return lines.length > 0 ? lines : [''];
  }

  // ---- Table Rendering Functions ------------------------------------------
  const TABLE_STYLES = {
    headerBg: [245, 192, 74],      // Gold #F5C04A
    headerText: [0, 0, 0],          // Black
    borderColor: [200, 200, 200],   // Light gray
    zebraColor: [248, 248, 248],    // Very light gray for alternate rows
    cellPadding: 2,                 // mm
    rowHeight: 8,                   // mm minimum row height
    headerHeight: 9,                // mm
    fontSize: 10,                   // pt
    headerFontSize: 10,             // pt
    borderWidth: 0.2,               // mm
    
    // Severity badge colors
    severityHigh: [220, 38, 38],    // Red
    severityMedium: [234, 88, 12],  // Orange
    severityLow: [22, 163, 74]      // Green
  };

  function getSeverityColor(severity) {
    const sev = severity.toLowerCase().trim();
    if (sev === 'high') return TABLE_STYLES.severityHigh;
    if (sev === 'medium') return TABLE_STYLES.severityMedium;
    if (sev === 'low') return TABLE_STYLES.severityLow;
    return TABLE_STYLES.headerText; // Default black
  }

  function calculateCellHeight(doc, text, width, fontSize = TABLE_STYLES.fontSize) {
    const maxTextWidth = width - (TABLE_STYLES.cellPadding * 2);
    doc.setFontSize(fontSize);
    const wrappedLines = wrapText(doc, text, maxTextWidth, fontSize);
    const lineHeight = 4; // mm per line
    const padding = TABLE_STYLES.cellPadding * 2 + 1; // Top + bottom padding
    return Math.max(TABLE_STYLES.rowHeight, (wrappedLines.length * lineHeight) + padding);
  }

  function drawTableCell(doc, text, x, y, width, height, options = {}) {
    const {
      isHeader = false,
      align = 'left',
      isSeverity = false,
      severity = null,
      isLink = false
    } = options;
    
    // Draw cell background
    if (isHeader) {
      doc.setFillColor(...TABLE_STYLES.headerBg);
      doc.rect(x, y, width, height, 'F');
    } else if (options.zebra) {
      doc.setFillColor(...TABLE_STYLES.zebraColor);
      doc.rect(x, y, width, height, 'F');
    }
    
    // Draw cell border
    doc.setDrawColor(...TABLE_STYLES.borderColor);
    doc.setLineWidth(TABLE_STYLES.borderWidth);
    doc.rect(x, y, width, height, 'S');
    
    // Set text style
    if (isHeader) {
      doc.setFont(TYPOGRAPHY.fontFamily, 'bold');
      doc.setFontSize(TABLE_STYLES.headerFontSize);
      doc.setTextColor(...TABLE_STYLES.headerText);
    } else if (isSeverity && severity) {
      doc.setFont(TYPOGRAPHY.fontFamily, 'bold');
      doc.setFontSize(TABLE_STYLES.fontSize);
      doc.setTextColor(...getSeverityColor(severity));
    } else if (isLink) {
      doc.setFont(TYPOGRAPHY.fontFamily, 'normal');
      doc.setFontSize(TABLE_STYLES.fontSize);
      doc.setTextColor(0, 0, 238); // Blue for links
    } else {
      doc.setFont(TYPOGRAPHY.fontFamily, 'normal');
      doc.setFontSize(TABLE_STYLES.fontSize);
      doc.setTextColor(...TYPOGRAPHY.colorBody);
    }
    
    // Wrap text to fit cell
    const maxTextWidth = width - (TABLE_STYLES.cellPadding * 2);
    const wrappedLines = wrapText(doc, text, maxTextWidth, TABLE_STYLES.fontSize);
    
    // Calculate text position
    let textY = y + TABLE_STYLES.cellPadding + 3;
    
    for (const line of wrappedLines) {
      let textX;
      if (align === 'center') {
        const textWidth = doc.getTextWidth(line);
        textX = x + (width - textWidth) / 2;
      } else if (align === 'right') {
        const textWidth = doc.getTextWidth(line);
        textX = x + width - TABLE_STYLES.cellPadding - textWidth;
      } else {
        textX = x + TABLE_STYLES.cellPadding;
      }
      
      // Render clickable link if this is a URL
      if (isLink && text.startsWith('http')) {
        doc.textWithLink(line, textX, textY, { url: text });
        // Underline the link
        const linkWidth = doc.getTextWidth(line);
        doc.setDrawColor(0, 0, 238);
        doc.setLineWidth(0.1);
        doc.line(textX, textY + 0.5, textX + linkWidth, textY + 0.5);
      } else {
        doc.text(line, textX, textY);
      }
      
      textY += 4; // Line spacing within cell
    }
    
    // Reset to body typography
    applyGlobalTypography(doc);
  }

  // ---- Content Writing with Pagination ------------------------------------
  class PDFWriter {
    constructor(doc, iconDataUrl) {
      this.doc = doc;
      this.iconDataUrl = iconDataUrl;
      this.pageNum = 1;
      this.yPosition = CONTENT.top + 2; // Add 2mm breathing room after header divider
      this.totalPages = 1;
    }
    
    needsNewPage(requiredHeight) {
      return window.YBG_PDF.shouldBreakBeforeLine(this.doc, this.yPosition, requiredHeight);
    }
    
    addNewPage() {
      this.totalPages++;
      this.pageNum = window.YBG_PDF.safeAddPage(this.doc, this.pageNum, (pageNum) => {
        drawWatermark(this.doc, this.iconDataUrl);
        drawHeader(this.doc, pageNum, this.iconDataUrl);
      });
      this.yPosition = CONTENT.top;  // Start below header, not at top margin
    }
    
    drawTableHeader(columnWidths, headers, columns) {
      let xPos = CONTENT.left;
      for (let i = 0; i < headers.length; i++) {
        drawTableCell(
          this.doc,
          headers[i],
          xPos,
          this.yPosition,
          columnWidths[i],
          TABLE_STYLES.headerHeight,
          { isHeader: true, align: columns[i].align || 'left' }
        );
        xPos += columnWidths[i];
      }
      this.yPosition += TABLE_STYLES.headerHeight;
    }

    writeTable(table) {
      // Calculate column widths
      const totalWidth = CONTENT.width;
      const columnWidths = table.columns.map(col => (totalWidth * col.width));
      
      // Add spacing before table
      if (this.yPosition > CONTENT.top + 10) {
        this.yPosition += TYPOGRAPHY.paragraphSpacing;
      }
      
      // Pre-calculate first row height for accurate space check
      let firstRowHeight = TABLE_STYLES.rowHeight;
      if (table.rows.length > 0) {
        const firstRow = table.rows[0];
        for (let colIdx = 0; colIdx < firstRow.length; colIdx++) {
          const cellText = firstRow[colIdx] || '';
          const cellHeight = calculateCellHeight(this.doc, cellText, columnWidths[colIdx]);
          firstRowHeight = Math.max(firstRowHeight, cellHeight);
        }
      }
      
      // Check if we have room for header + first row (with actual height)
      const minTableHeight = TABLE_STYLES.headerHeight + firstRowHeight;
      if (this.needsNewPage(minTableHeight)) {
        this.addNewPage();
      }
      
      // Draw initial header
      this.drawTableHeader(columnWidths, table.headers, table.columns);
      
      // Draw data rows with dynamic heights
      for (let rowIdx = 0; rowIdx < table.rows.length; rowIdx++) {
        const row = table.rows[rowIdx];
        
        // Calculate row height based on tallest cell
        let rowHeight = TABLE_STYLES.rowHeight;
        for (let colIdx = 0; colIdx < row.length; colIdx++) {
          const cellText = row[colIdx] || '';
          const cellHeight = calculateCellHeight(this.doc, cellText, columnWidths[colIdx]);
          rowHeight = Math.max(rowHeight, cellHeight);
        }
        
        // Check if we need a new page for this row
        if (this.needsNewPage(rowHeight)) {
          this.addNewPage();
          // Redraw header on new page
          this.drawTableHeader(columnWidths, table.headers, table.columns);
        }
        
        let xPos = CONTENT.left;
        const isZebra = rowIdx % 2 === 1;
        
        for (let colIdx = 0; colIdx < row.length; colIdx++) {
          const cellText = row[colIdx] || '';
          const column = table.columns[colIdx];
          
          // Check if this is a severity column for Risk Matrix
          const isSeverityCol = column.isSeverity === true;
          
          // Check if this is a link column (URL detection)
          const isLinkCol = cellText.startsWith('http://') || cellText.startsWith('https://');
          
          drawTableCell(
            this.doc,
            cellText,
            xPos,
            this.yPosition,
            columnWidths[colIdx],
            rowHeight, // Use calculated dynamic height
            {
              zebra: isZebra,
              align: column.align || 'left',
              isSeverity: isSeverityCol,
              severity: isSeverityCol ? cellText : null,
              isLink: isLinkCol
            }
          );
          xPos += columnWidths[colIdx];
        }
        
        this.yPosition += rowHeight; // Use calculated height
      }
      
      // Add spacing after table
      this.yPosition += TYPOGRAPHY.paragraphSpacing;
      
      // Reset typography
      applyGlobalTypography(this.doc);
    }
    
    writeBlock(block) {
      // Handle table blocks
      if (block.type === 'table') {
        this.writeTable(block.data);
        return;
      }
      let fontSize = TYPOGRAPHY.bodySize;
      let lineHeight = TYPOGRAPHY.lineHeight;
      let isBold = false;
      let textColor = TYPOGRAPHY.colorBody;
      
      // Configure style based on block type
      switch (block.type) {
        case 'h2':
          fontSize = TYPOGRAPHY.h2Size;
          lineHeight = TYPOGRAPHY.h2LineHeight;
          isBold = true;
          textColor = TYPOGRAPHY.colorHeading;
          // Add space before heading
          if (this.yPosition > CONTENT.top + 10) {
            this.yPosition += TYPOGRAPHY.paragraphSpacing;
          }
          break;
          
        case 'h3':
          fontSize = TYPOGRAPHY.h3Size;
          lineHeight = TYPOGRAPHY.h3LineHeight;
          isBold = true;
          textColor = TYPOGRAPHY.colorHeading;
          // Add space before heading
          if (this.yPosition > CONTENT.top + 10) {
            this.yPosition += TYPOGRAPHY.paragraphSpacing * 0.8;
          }
          break;
          
        case 'metadata':
          fontSize = 9;
          lineHeight = 4.5;
          textColor = TYPOGRAPHY.colorMeta;
          // Remove ** markers for bold metadata
          block.text = block.text.replace(/\*\*/g, '');
          isBold = block.text.includes('Generated:');
          break;
          
        case 'separator':
          // Check space for separator
          if (this.needsNewPage(10)) {
            this.addNewPage();
          }
          this.yPosition += 5;
          this.doc.setDrawColor(245, 192, 74); // Gold accent separator
          this.doc.setLineWidth(0.3);
          this.doc.line(CONTENT.left, this.yPosition, CONTENT.right, this.yPosition);
          this.yPosition += 5;
          return;
          
        case 'blank':
          this.yPosition += TYPOGRAPHY.paragraphSpacing * 0.5;
          return;
      }
      
      // Wrap text
      const lines = wrapText(this.doc, block.text, CONTENT.width, fontSize);
      
      // Calculate required height
      const blockHeight = lines.length * lineHeight;
      
      // Check for widows/orphans (keep at least 2 lines together)
      if (lines.length > 1 && this.needsNewPage(blockHeight)) {
        // If we can fit at least 2 lines, do it; otherwise new page
        const minLines = Math.min(2, lines.length);
        const minHeight = minLines * lineHeight;
        
        if (!this.needsNewPage(minHeight)) {
          // Write first few lines on current page
          this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
          this.doc.setFontSize(fontSize);
          this.doc.setTextColor(...textColor);
          
          for (let i = 0; i < minLines; i++) {
            this.doc.text(lines[i], CONTENT.left, this.yPosition);
            this.yPosition += lineHeight;
          }
          
          // Move to new page for remaining lines
          this.addNewPage();
          
          // Write remaining lines
          this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
          this.doc.setFontSize(fontSize);
          this.doc.setTextColor(...textColor);
          
          for (let i = minLines; i < lines.length; i++) {
            this.doc.text(lines[i], CONTENT.left, this.yPosition);
            this.yPosition += lineHeight;
          }
        } else {
          // Move everything to new page
          this.addNewPage();
          
          // Write all lines
          this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
          this.doc.setFontSize(fontSize);
          this.doc.setTextColor(...textColor);
          
          for (const line of lines) {
            this.doc.text(line, CONTENT.left, this.yPosition);
            this.yPosition += lineHeight;
          }
        }
      } else {
        // Write on current page
        this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
        this.doc.setFontSize(fontSize);
        this.doc.setTextColor(...textColor);
        
        for (const line of lines) {
          if (this.needsNewPage(lineHeight)) {
            this.addNewPage();
            this.doc.setFont(TYPOGRAPHY.fontFamily, isBold ? "bold" : "normal");
            this.doc.setFontSize(fontSize);
            this.doc.setTextColor(...textColor);
          }
          
          this.doc.text(line, CONTENT.left, this.yPosition);
          this.yPosition += lineHeight;
        }
      }
      
      // Add paragraph spacing after block
      if (block.type === 'paragraph') {
        this.yPosition += TYPOGRAPHY.paragraphSpacing * 0.6;
      } else if (block.type === 'metadata') {
        // Tighter spacing for metadata, but add extra after Generated line
        if (block.text.includes('Generated:')) {
          this.yPosition += 2.5; // Extra space after Generated line
        } else {
          this.yPosition += 0.8; // Minimal spacing for other metadata
        }
      }
      
      // Reset typography
      applyGlobalTypography(this.doc);
    }
    
    finalize() {
      // Draw footers on all pages (no logo in footer)
      for (let i = 1; i <= this.totalPages; i++) {
        this.doc.setPage(i);
        drawFooter(this.doc, i, this.totalPages);
      }
    }
  }

  // ---- Result Collection (Match YBGToolkit storage) ------------------------
  function getToolkitStorageKey() {
    // Match the exact same logic as YBGToolkit.getStorageKey()
    const toolkitName = getToolkitName().toLowerCase().replace(/\s+/g, '_');
    return `ybg_toolkit_results_${toolkitName}`;
  }

  function collectResults() {
    // Get results from localStorage using the same key as YBGToolkit
    const storageKey = getToolkitStorageKey();
    
    try {
      const stored = localStorage.getItem(storageKey);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed)) {
          console.log('PDF Export: Retrieved', parsed.length, 'results from storage:', storageKey);
          return parsed;
        }
      }
    } catch (e) {
      console.error('PDF Export: Error parsing stored results:', e);
    }
    
    console.log('PDF Export: No results found in storage key:', storageKey);
    return [];
  }

  // ---- Main Export Functions -----------------------------------------------
  async function exportSingleResult(text, resultTitle) {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'mm', format: 'a4' });
    
    // Load icon
    const iconDataUrl = await loadImageAsDataURL(getToolkitIcon());
    
    // Initialize writer
    const writer = new PDFWriter(doc, iconDataUrl);
    
    // Apply safe body style for consistent typography
    window.YBG_PDF.applyBodyStyle(doc);
    
    // Draw watermark and header on first page
    drawWatermark(doc, iconDataUrl);
    drawHeader(doc, 1, iconDataUrl);
    
    // Parse and write content
    const blocks = parseContent(text);
    
    if (blocks.length === 0) {
      writer.writeBlock({
        type: 'paragraph',
        text: 'No content available.'
      });
    } else {
      for (const block of blocks) {
        writer.writeBlock(block);
      }
    }
    
    // Finalize (add footers)
    writer.finalize();
    
    // Generate filename
    const date = new Date();
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    const safeName = getToolkitName().replace(/[^a-zA-Z0-9]/g, '');
    const filename = `${safeName}_${yyyy}-${mm}-${dd}_Report.pdf`;
    
    doc.save(filename);
  }

  async function exportMultipleResults(mode = 'all') {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'mm', format: 'a4' });
    
    // Load icon
    const iconDataUrl = await loadImageAsDataURL(getToolkitIcon());
    
    // Initialize writer
    const writer = new PDFWriter(doc, iconDataUrl);
    
    // Apply safe body style for consistent typography
    window.YBG_PDF.applyBodyStyle(doc);
    
    // Draw watermark and header on first page
    drawWatermark(doc, iconDataUrl);
    drawHeader(doc, 1, iconDataUrl);
    
    // Collect results from storage
    let results = collectResults();
    
    console.log('PDF Export: Collected', results.length, 'results for mode:', mode);
    
    if (results.length > 0) {
      // Sort by timestamp (oldest to newest for proper chronological order)
      results.sort((a, b) => {
        const timestampA = new Date(a.timestamp).getTime();
        const timestampB = new Date(b.timestamp).getTime();
        return timestampA - timestampB;
      });
      
      // Filter based on mode
      if (mode === 'latest') {
        results = [results[results.length - 1]]; // Take only the most recent
        console.log('PDF Export: Using latest result only');
      }
    }
    
    // Write results
    if (results.length === 0) {
      writer.writeBlock({
        type: 'paragraph',
        text: 'No results available.'
      });
    } else {
      results.forEach((result, index) => {
        // Add separator between results (except first)
        if (index > 0) {
          writer.writeBlock({ type: 'separator', text: '' });
        }
        
        // Result header
        const headerText = mode === 'latest' ? 
          'Latest Result' : 
          `Result ${index + 1}`;
        
        // Use current date/time for PDF generation timestamp
        const currentDate = new Date();
        const formattedTimestamp = currentDate.toLocaleString('en-US', {
          month: '2-digit',
          day: '2-digit', 
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        });
        
        writer.writeBlock({
          type: 'h2',
          text: `${headerText} - Generated: ${formattedTimestamp}`
        });
        
        // Prompt if available
        if (result.prompt) {
          writer.writeBlock({
            type: 'h3',
            text: 'Request'
          });
          writer.writeBlock({
            type: 'paragraph',
            text: result.prompt
          });
        }
        
        // Result content
        if (result.result) {
          writer.writeBlock({
            type: 'h3',
            text: 'Response'
          });
          
          // Parse the result text for any markdown formatting
          const contentBlocks = parseContent(result.result);
          for (const block of contentBlocks) {
            writer.writeBlock(block);
          }
        }
      });
    }
    
    // Finalize (add footers)
    writer.finalize();
    
    // Generate filename based on mode
    const date = new Date();
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    const safeName = getToolkitName().replace(/[^a-zA-Z0-9]/g, '');
    
    const suffix = mode === 'latest' ? 'Latest_Result' : 'All_Results';
    const filename = `GrantGenie_${yyyy}-${mm}-${dd}_${suffix}.pdf`;
    
    doc.save(filename);
  }

  // ---- Public API ----------------------------------------------------------
  window.exportResultToPDF = function(text) {
    // Single result export (from Download button)
    return exportSingleResult(text || '');
  };

  // Helper: Convert HTML to markdown-like text for PDF rendering
  function htmlToMarkdown(html) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    
    let markdown = '';
    
    function processNode(node) {
      // Text nodes
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        if (text) markdown += text + ' ';
        return;
      }
      
      // Element nodes
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        
        // Special handling for metadata sections
        if (node.classList && node.classList.contains('pdf-header')) {
          // Extract Generated line and checksum
          const tinyDiv = node.querySelector('.tiny');
          if (tinyDiv) {
            markdown += '\n**' + tinyDiv.textContent.trim() + '**\n\n';
          }
          return;
        }
        
        if (node.classList && node.classList.contains('doc-meta')) {
          // Format metadata as a clean table-like structure
          const metaItems = node.querySelectorAll('div');
          for (const item of metaItems) {
            const text = item.textContent.trim();
            if (text) {
              markdown += text + '\n';
            }
          }
          markdown += '\n';
          return;
        }
        
        switch (tagName) {
          case 'h2':
            markdown += '\n## ' + node.textContent.trim() + '\n\n';
            break;
          
          case 'h3':
            markdown += '\n### ' + node.textContent.trim() + '\n\n';
            break;
          
          case 'hr':
            markdown += '\n---\n\n';
            break;
          
          case 'p':
          case 'div':
            // Process children first
            for (const child of node.childNodes) {
              processNode(child);
            }
            markdown += '\n';
            break;
          
          case 'ul':
            for (const li of node.querySelectorAll(':scope > li')) {
              markdown += '• ' + li.textContent.trim() + '\n';
            }
            markdown += '\n';
            break;
          
          case 'ol':
            for (const li of node.querySelectorAll(':scope > li')) {
              const text = li.textContent.trim();
              // Check if text already starts with a number (manual numbering)
              // If so, use it as-is; otherwise add automatic numbering
              if (/^\d+\./.test(text)) {
                markdown += text + '\n';
              } else {
                // Fallback: add automatic numbering for lists without manual numbers
                const index = Array.from(node.querySelectorAll(':scope > li')).indexOf(li) + 1;
                markdown += `${index}. ` + text + '\n';
              }
            }
            markdown += '\n';
            break;
          
          case 'table':
            // Convert HTML table to text representation
            const rows = node.querySelectorAll('tr');
            for (const row of rows) {
              const cells = row.querySelectorAll('th, td');
              const cellTexts = Array.from(cells).map(cell => cell.textContent.trim());
              markdown += cellTexts.join(' | ') + '\n';
            }
            markdown += '\n';
            break;
          
          case 'strong':
          case 'b':
            markdown += '**' + node.textContent.trim() + '**';
            break;
          
          case 'em':
          case 'i':
            markdown += '*' + node.textContent.trim() + '*';
            break;
          
          case 'br':
            markdown += '\n';
            break;
          
          default:
            // For unhandled tags, process children
            for (const child of node.childNodes) {
              processNode(child);
            }
            break;
        }
      }
    }
    
    // Process all top-level children
    for (const child of tempDiv.childNodes) {
      processNode(child);
    }
    
    return markdown.trim();
  }

  window.exportAllResultsToPDF = function(resultsArray, options = {}) {
    // NEW: Handle HTML-based export from unified renderer
    if (Array.isArray(resultsArray) && resultsArray.length > 0 && resultsArray[0]?.html) {
      const item = resultsArray[0];
      const htmlContent = item.html;
      
      // Convert HTML to markdown-like text for PDF rendering (preserves structure)
      const markdownContent = htmlToMarkdown(htmlContent);
      
      // Use provided fileName or generate default
      const customFilename = item.fileName || `GrantGenie_${Date.now()}.pdf`;
      
      // Export with custom filename handling
      return exportSingleResultWithFilename(markdownContent, customFilename);
    }
    
    // Legacy: array of strings
    if (Array.isArray(resultsArray) && resultsArray.length > 0 && typeof resultsArray[0] === 'string') {
      const combined = resultsArray.join('\n\n---\n\n');
      return exportSingleResult(combined);
    }
    
    // Fallback: use mode-based export from localStorage
    const mode = options.mode || 'all';
    return exportMultipleResults(mode);
  };
  
  // Helper: Export with custom filename
  async function exportSingleResultWithFilename(text, filename) {
    const jsPDF = await loadJsPDF();
    const doc = new jsPDF({ unit: 'mm', format: 'a4' });
    
    // Load icon
    const iconDataUrl = await loadImageAsDataURL(getToolkitIcon());
    
    // Initialize writer
    const writer = new PDFWriter(doc, iconDataUrl);
    
    // Apply safe body style
    window.YBG_PDF.applyBodyStyle(doc);
    
    // Draw watermark and header on first page
    drawWatermark(doc, iconDataUrl);
    drawHeader(doc, 1, iconDataUrl);
    
    // Parse and write content
    const blocks = parseContent(text);
    
    if (blocks.length === 0) {
      writer.writeBlock({
        type: 'paragraph',
        content: 'No content available.'
      });
    } else {
      for (const block of blocks) {
        writer.writeBlock(block);
      }
    }
    
    // Finalize
    writer.finalize();
    
    // Save with custom filename
    doc.save(filename);
  }

  // ---- Elev8 Analyzer PDF Export (Diagnostic Format) ----------------------
  window.exportElev8AnalysisToPDF = async function(analysis) {
    try {
      console.log('[PDF Export] Starting export with MARGINS:', MARGINS);
      console.log('[PDF Export] CONTENT area:', CONTENT);
      console.log('[PDF Export] HEADER:', HEADER);
      console.log('[PDF Export] FOOTER:', FOOTER);
      
      const jsPDF = await loadJsPDF();
      const doc = new jsPDF({ unit: 'mm', format: 'a4' });
      
      // Load icon
      const iconDataUrl = await loadImageAsDataURL(getToolkitIcon());
      
      // Apply global typography
      applyGlobalTypography(doc);
      
      const overallIndex = analysis.overall?.score || 0;
      const businessName = analysis.businessName || 'Business';
      const timestamp = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
      
      let currentY = CONTENT.top;
      let pageNum = 1;
      
      // ---- Page 1: Cover Page ----
      drawWatermark(doc, iconDataUrl);
      drawHeader(doc, pageNum, iconDataUrl);
      
      // Title
      doc.setFont(TYPOGRAPHY.fontFamily, "bold");
      doc.setFontSize(22);
      doc.setTextColor(8, 145, 178); // Teal
      currentY = CONTENT.top + 30;
      doc.text("Elev8 Analyzer Report", CONTENT.left, currentY, { align: 'left' });
      
      // Business name
      doc.setFont(TYPOGRAPHY.fontFamily, "normal");
      doc.setFontSize(16);
      doc.setTextColor(...TYPOGRAPHY.colorBody);
      currentY += 12;
      doc.text(businessName, CONTENT.left, currentY);
      
      // Timestamp
      doc.setFontSize(11);
      doc.setTextColor(...TYPOGRAPHY.colorMeta);
      currentY += 8;
      doc.text(`Generated: ${timestamp}`, CONTENT.left, currentY);
      
      // Overall Index (large display)
      currentY += 25;
      doc.setFont(TYPOGRAPHY.fontFamily, "bold");
      doc.setFontSize(48);
      doc.setTextColor(8, 145, 178); // Teal
      doc.text(`${overallIndex}`, CONTENT.left, currentY);
      
      doc.setFontSize(14);
      doc.setTextColor(...TYPOGRAPHY.colorMeta);
      doc.text("Overall Elev8 Index", CONTENT.left + 30, currentY);
      
      // Executive summary
      if (analysis.overall?.summary) {
        currentY += 15;
        doc.setFont(TYPOGRAPHY.fontFamily, "normal");
        doc.setFontSize(TYPOGRAPHY.bodySize);
        doc.setTextColor(...TYPOGRAPHY.colorBody);
        
        const summaryLines = doc.splitTextToSize(analysis.overall.summary, CONTENT.width - 20);
        doc.text(summaryLines, CONTENT.left, currentY);
        currentY += summaryLines.length * TYPOGRAPHY.lineHeight;
      }
      
      // ---- Page 2+: 8 Pillar Breakdown ----
      doc.addPage();
      pageNum++;
      applyGlobalTypography(doc);
      drawWatermark(doc, iconDataUrl);
      drawHeader(doc, pageNum, iconDataUrl);
      
      currentY = CONTENT.top;
      
      // Section heading
      doc.setFont(TYPOGRAPHY.fontFamily, "bold");
      doc.setFontSize(16);
      doc.setTextColor(...TYPOGRAPHY.colorHeading);
      doc.text("8 Pillars of Business Health", CONTENT.left, currentY);
      currentY += 10;
      
      // Render each pillar
      const pillars = analysis.pillars || [];
      
      for (let i = 0; i < pillars.length; i++) {
        const pillar = pillars[i];
        
        // Check if we need a new page
        if (currentY > CONTENT.bottom - 60) {
          doc.addPage();
          pageNum++;
          applyGlobalTypography(doc);
          drawWatermark(doc, iconDataUrl);
          drawHeader(doc, pageNum, iconDataUrl);
          currentY = CONTENT.top;
        }
        
        // Pillar name
        doc.setFont(TYPOGRAPHY.fontFamily, "bold");
        doc.setFontSize(13);
        doc.setTextColor(...TYPOGRAPHY.colorHeading);
        doc.text(`${i + 1}. ${pillar.name}`, CONTENT.left, currentY);
        
        // Score badge
        const scoreColor = pillar.score >= 71 ? [16, 185, 129] : pillar.score >= 41 ? [234, 179, 8] : [239, 68, 68];
        doc.setTextColor(...scoreColor);
        doc.text(`Score: ${pillar.score}/100`, CONTENT.right - 30, currentY, { align: 'right' });
        
        currentY += 7;
        
        // Insights
        doc.setFont(TYPOGRAPHY.fontFamily, "bold");
        doc.setFontSize(10);
        doc.setTextColor(...TYPOGRAPHY.colorBody);
        doc.text("Key Insights:", CONTENT.left + 3, currentY);
        currentY += 5;
        
        doc.setFont(TYPOGRAPHY.fontFamily, "normal");
        doc.setFontSize(10);
        
        (pillar.insights || []).forEach(insight => {
          const lines = doc.splitTextToSize(`• ${insight}`, CONTENT.width - 10);
          doc.text(lines, CONTENT.left + 3, currentY);
          currentY += lines.length * 4.5;
        });
        
        currentY += 3;
        
        // Actions
        doc.setFont(TYPOGRAPHY.fontFamily, "bold");
        doc.setFontSize(10);
        doc.text("Priority Actions:", CONTENT.left + 3, currentY);
        currentY += 5;
        
        doc.setFont(TYPOGRAPHY.fontFamily, "normal");
        doc.setFontSize(10);
        
        (pillar.actions || []).forEach((action, idx) => {
          const lines = doc.splitTextToSize(`${idx + 1}. ${action}`, CONTENT.width - 10);
          doc.text(lines, CONTENT.left + 3, currentY);
          currentY += lines.length * 4.5;
        });
        
        currentY += 8;
        
        // Divider line
        if (i < pillars.length - 1) {
          doc.setDrawColor(200, 200, 200);
          doc.line(CONTENT.left, currentY - 2, CONTENT.right, currentY - 2);
          currentY += 2;
        }
      }
      
      // ---- New Page: 30/60/90 Roadmap ----
      doc.addPage();
      pageNum++;
      applyGlobalTypography(doc);
      drawWatermark(doc, iconDataUrl);
      drawHeader(doc, pageNum, iconDataUrl);
      
      currentY = CONTENT.top;
      
      // Section heading
      doc.setFont(TYPOGRAPHY.fontFamily, "bold");
      doc.setFontSize(16);
      doc.setTextColor(...TYPOGRAPHY.colorHeading);
      doc.text("30/60/90-Day Action Roadmap", CONTENT.left, currentY);
      currentY += 12;
      
      const roadmap = analysis.roadmap || {};
      const phases = [
        { title: '30 Days (Quick Wins)', actions: roadmap.d30 || [], color: [16, 185, 129] },
        { title: '60 Days (Process Improvements)', actions: roadmap.d60 || [], color: [8, 145, 178] },
        { title: '90 Days (Strategic Initiatives)', actions: roadmap.d90 || [], color: [139, 92, 246] }
      ];
      
      phases.forEach((phase, phaseIdx) => {
        // Check if we need a new page
        if (currentY > CONTENT.bottom - 40) {
          doc.addPage();
          pageNum++;
          applyGlobalTypography(doc);
          drawWatermark(doc, iconDataUrl);
          drawHeader(doc, pageNum, iconDataUrl);
          currentY = CONTENT.top;
        }
        
        // Phase title
        doc.setFont(TYPOGRAPHY.fontFamily, "bold");
        doc.setFontSize(12);
        doc.setTextColor(...phase.color);
        doc.text(phase.title, CONTENT.left, currentY);
        currentY += 7;
        
        // Phase actions
        doc.setFont(TYPOGRAPHY.fontFamily, "normal");
        doc.setFontSize(10);
        doc.setTextColor(...TYPOGRAPHY.colorBody);
        
        phase.actions.forEach((action, idx) => {
          const lines = doc.splitTextToSize(`${idx + 1}. ${action}`, CONTENT.width - 8);
          doc.text(lines, CONTENT.left + 3, currentY);
          currentY += lines.length * 4.5 + 1;
        });
        
        currentY += 5;
      });
      
      // ---- Add Footers to All Pages ----
      const totalPages = pageNum;
      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        await drawFooter(doc, i, totalPages);
      }
      
      // Save PDF with timestamp
      const filename = `Elev8_Business_Analysis_${businessName.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
      doc.save(filename);
      
    } catch (error) {
      console.error('PDF Export Error:', error);
      alert('Failed to export PDF. Please try again.');
    }
  };

  // Additional API aliases (extend existing YBG_PDF object)
  Object.assign(window.YBG_PDF, {
    exportResultToPDF: window.exportResultToPDF,
    exportAllResultsToPDF: window.exportAllResultsToPDF,
    exportLatestResult: () => exportMultipleResults('latest'),
    exportAllResults: () => exportMultipleResults('all'),
    exportElev8Analysis: window.exportElev8AnalysisToPDF
  });

})();